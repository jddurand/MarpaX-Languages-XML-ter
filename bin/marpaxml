#!perl
use Getopt::Long;
use IO::All;
use IO::All::LWP;
use MarpaX::Languages::XML;
use Moops;
use Log::Any qw/$log/;
use Log::Any::Adapter;
use Log::Log4perl qw/:easy/;
use MarpaX::Languages::XML::Impl::IO;
use POSIX qw/EXIT_FAILURE EXIT_SUCCESS/;
use Try::Tiny;
use Types::Standard -all;
use XML::NamespaceSupport;

# ABSTRACT: Marpa/Moops powered XML parser in Perl

# VERSION

# AUTHORITY

# PODNAME: marpaxml

class Reader {
  use MarpaX::Languages::XML::Role::Reader;

  has io_all => (is => 'ro', isa => InstanceOf['IO::All'], required => 1);
  has _eof   => (is => 'rw', isa => Bool, default => false);

  my $buffer = '';
  method BUILD {
    $self->io_all->binmode;               # bytes only
    $self->io_all->buffer(\$buffer);      # internal read buffer
  }

  {
    no warnings 'redefine';
    #
    # We follow exactly Java's *Stream semantics:
    #
    # Reads up to len bytes of data from the input stream into an array of bytes.
    # An attempt is made to read as many as len bytes, but a smaller number may be read. The number of bytes actually read is returned as an integer.
    #
    # This method blocks until input data is available, end of file is detected, or an exception is thrown.
    #
    # If len is zero, then no bytes are read and 0 is returned; otherwise, there is an attempt to read at least one byte.
    # If no byte is available because the stream is at end of file, the value -1 is returned; otherwise, at least one byte is read and stored into b.

    method read(... --> Int) {
      (! $_[2])   && return  0;                            # If len is zero, then no bytes are read and 0 is returned
      $self->_eof && return -1;                            # If no byte is available because the stream is at end of file, the value -1 is returned
      #
      # Take care: underlying read can read MORE than asked
      #
      my $currentLength = length($buffer);
      if ($currentLength < $_[2]) {
        my $need = $_[2] - $currentLength;
        $self->io_all->block_size($need), $self->io_all->read;     # Reads up to needed bytes of data - we assume underlying read will block until some bytes, or EOF, or error
        $currentLength = length($buffer);
      }
      my $done = ($currentLength <= $_[2]) ? $currentLength : $_[2];
      ! $done && $self->_eof(true) && return -1;           # We do not trust underlying EOF
      substr($_[0], $_[1], $done, substr($buffer, 0, $done, '')), $done
    }
  }

  with 'MarpaX::Languages::XML::Role::Reader';
}

my $xml = MarpaX::Languages::XML->new_with_options;
__PACKAGE__->_init_log4perl($xml->loglevel);
foreach (@ARGV) {
  $xml->parser->parse(Reader->new(io_all => io($_)), $xml->startsymbol);
}

exit(EXIT_SUCCESS);

##################################################"

sub _init_log4perl {
  my ($class, $loglevel) = @_;

  my $defaultLog4perlConf = <<DEFAULT_LOG4PERL_CONF;
log4perl.rootLogger              = $loglevel, Screen
log4perl.appender.Screen         = Log::Log4perl::Appender::Screen
log4perl.appender.Screen.layout  = PatternLayout
log4perl.appender.Screen.layout.ConversionPattern = %d %-5p %6P %m{chomp}%n
DEFAULT_LOG4PERL_CONF
   Log::Log4perl::init(\$defaultLog4perlConf);
   Log::Any::Adapter->set('Log4perl');
}

